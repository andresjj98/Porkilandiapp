{"ast":null,"code":"// Función para restar productos del inventario usando lógica UEPS\nexport const subtractFromInventory = (cuts, invoices, orderItems) => {\n  // Clonar los cortes para no modificar el estado directamente\n  const updatedCuts = [...cuts];\n\n  // Ordenar los cortes por fecha de procesamiento descendente (UEPS)\n  const sortedCuts = [...updatedCuts].sort((a, b) => {\n    const dateA = new Date(a.processingDate);\n    const dateB = new Date(b.processingDate);\n    return dateB - dateA; // Más reciente primero\n  });\n\n  // Crear un mapa de cortes disponibles por tipo de corte y origen (factura)\n  const availableCutsMap = sortedCuts.reduce((acc, cut) => {\n    const invoice = invoices.find(inv => inv.id === cut.invoiceId);\n    const originInvoiceNumber = invoice ? invoice.number : 'Desconocida';\n    const key = `${cut.cutType}-${originInvoiceNumber}`;\n    if (!acc[key]) {\n      acc[key] = [];\n    }\n    acc[key].push(cut);\n    return acc;\n  }, {});\n\n  // Procesar cada item de la orden\n  for (const item of orderItems) {\n    const requestedQuantity = item.quantity || 0;\n    const requestedWeight = item.weight || 0;\n\n    // Buscar cortes disponibles que coincidan con el tipo de carne y corte solicitado\n    // Aquí la lógica UEPS ya está aplicada por el ordenamiento inicial\n    const matchingCuts = Object.entries(availableCutsMap).filter(([key]) => key.startsWith(`${item.cutType}-`)) // Filtrar por tipo de corte\n    .flatMap(([key, cuts]) => cuts); // Aplanar la lista de cortes\n\n    let remainingQuantity = requestedQuantity;\n    let remainingWeight = requestedWeight;\n\n    // Restar del inventario usando los cortes encontrados (ya ordenados por UEPS)\n    for (const cut of matchingCuts) {\n      if (remainingQuantity <= 0 && remainingWeight <= 0) break; // Ya surtimos lo necesario\n\n      // Lógica para restar por cantidad\n      if (requestedQuantity > 0 && cut.quantity > 0) {\n        const quantityToSubtract = Math.min(remainingQuantity, cut.quantity);\n        cut.quantity -= quantityToSubtract;\n        remainingQuantity -= quantityToSubtract;\n      }\n\n      // Lógica para restar por peso\n      if (requestedWeight > 0 && cut.weight > 0) {\n        const weightToSubtract = Math.min(remainingWeight, cut.weight);\n        cut.weight -= weightToSubtract;\n        remainingWeight -= weightToSubtract;\n      }\n    }\n  }\n\n  // Filtrar cortes con cantidad o peso cero si es necesario (opcional)\n  // const finalCuts = updatedCuts.filter(cut => cut.quantity > 0 || cut.weight > 0);\n\n  return updatedCuts; // Devolver los cortes actualizados\n};","map":{"version":3,"names":["subtractFromInventory","cuts","invoices","orderItems","updatedCuts","sortedCuts","sort","a","b","dateA","Date","processingDate","dateB","availableCutsMap","reduce","acc","cut","invoice","find","inv","id","invoiceId","originInvoiceNumber","number","key","cutType","push","item","requestedQuantity","quantity","requestedWeight","weight","matchingCuts","Object","entries","filter","startsWith","flatMap","remainingQuantity","remainingWeight","quantityToSubtract","Math","min","weightToSubtract"],"sources":["D:/Programas/porkiapp_v1.0/front-end/src/utils/inventoryLogic.js"],"sourcesContent":["// Función para restar productos del inventario usando lógica UEPS\nexport const subtractFromInventory = (cuts, invoices, orderItems) => {\n  // Clonar los cortes para no modificar el estado directamente\n  const updatedCuts = [...cuts];\n\n  // Ordenar los cortes por fecha de procesamiento descendente (UEPS)\n  const sortedCuts = [...updatedCuts].sort((a, b) => {\n    const dateA = new Date(a.processingDate);\n    const dateB = new Date(b.processingDate);\n    return dateB - dateA; // Más reciente primero\n  });\n\n  // Crear un mapa de cortes disponibles por tipo de corte y origen (factura)\n  const availableCutsMap = sortedCuts.reduce((acc, cut) => {\n    const invoice = invoices.find(inv => inv.id === cut.invoiceId);\n    const originInvoiceNumber = invoice ? invoice.number : 'Desconocida';\n    const key = `${cut.cutType}-${originInvoiceNumber}`;\n\n    if (!acc[key]) {\n      acc[key] = [];\n    }\n    acc[key].push(cut);\n    return acc;\n  }, {});\n\n  // Procesar cada item de la orden\n  for (const item of orderItems) {\n    const requestedQuantity = item.quantity || 0;\n    const requestedWeight = item.weight || 0;\n\n    // Buscar cortes disponibles que coincidan con el tipo de carne y corte solicitado\n    // Aquí la lógica UEPS ya está aplicada por el ordenamiento inicial\n    const matchingCuts = Object.entries(availableCutsMap)\n      .filter(([key]) => key.startsWith(`${item.cutType}-`)) // Filtrar por tipo de corte\n      .flatMap(([key, cuts]) => cuts); // Aplanar la lista de cortes\n\n    let remainingQuantity = requestedQuantity;\n    let remainingWeight = requestedWeight;\n\n    // Restar del inventario usando los cortes encontrados (ya ordenados por UEPS)\n    for (const cut of matchingCuts) {\n      if (remainingQuantity <= 0 && remainingWeight <= 0) break; // Ya surtimos lo necesario\n\n      // Lógica para restar por cantidad\n      if (requestedQuantity > 0 && cut.quantity > 0) {\n        const quantityToSubtract = Math.min(remainingQuantity, cut.quantity);\n        cut.quantity -= quantityToSubtract;\n        remainingQuantity -= quantityToSubtract;\n      }\n\n      // Lógica para restar por peso\n      if (requestedWeight > 0 && cut.weight > 0) {\n        const weightToSubtract = Math.min(remainingWeight, cut.weight);\n        cut.weight -= weightToSubtract;\n        remainingWeight -= weightToSubtract;\n      }\n    }\n  }\n\n  // Filtrar cortes con cantidad o peso cero si es necesario (opcional)\n  // const finalCuts = updatedCuts.filter(cut => cut.quantity > 0 || cut.weight > 0);\n\n  return updatedCuts; // Devolver los cortes actualizados\n};"],"mappings":"AAAA;AACA,OAAO,MAAMA,qBAAqB,GAAGA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,UAAU,KAAK;EACnE;EACA,MAAMC,WAAW,GAAG,CAAC,GAAGH,IAAI,CAAC;;EAE7B;EACA,MAAMI,UAAU,GAAG,CAAC,GAAGD,WAAW,CAAC,CAACE,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;IACjD,MAAMC,KAAK,GAAG,IAAIC,IAAI,CAACH,CAAC,CAACI,cAAc,CAAC;IACxC,MAAMC,KAAK,GAAG,IAAIF,IAAI,CAACF,CAAC,CAACG,cAAc,CAAC;IACxC,OAAOC,KAAK,GAAGH,KAAK,CAAC,CAAC;EACxB,CAAC,CAAC;;EAEF;EACA,MAAMI,gBAAgB,GAAGR,UAAU,CAACS,MAAM,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAK;IACvD,MAAMC,OAAO,GAAGf,QAAQ,CAACgB,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACC,EAAE,KAAKJ,GAAG,CAACK,SAAS,CAAC;IAC9D,MAAMC,mBAAmB,GAAGL,OAAO,GAAGA,OAAO,CAACM,MAAM,GAAG,aAAa;IACpE,MAAMC,GAAG,GAAG,GAAGR,GAAG,CAACS,OAAO,IAAIH,mBAAmB,EAAE;IAEnD,IAAI,CAACP,GAAG,CAACS,GAAG,CAAC,EAAE;MACbT,GAAG,CAACS,GAAG,CAAC,GAAG,EAAE;IACf;IACAT,GAAG,CAACS,GAAG,CAAC,CAACE,IAAI,CAACV,GAAG,CAAC;IAClB,OAAOD,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,CAAC;;EAEN;EACA,KAAK,MAAMY,IAAI,IAAIxB,UAAU,EAAE;IAC7B,MAAMyB,iBAAiB,GAAGD,IAAI,CAACE,QAAQ,IAAI,CAAC;IAC5C,MAAMC,eAAe,GAAGH,IAAI,CAACI,MAAM,IAAI,CAAC;;IAExC;IACA;IACA,MAAMC,YAAY,GAAGC,MAAM,CAACC,OAAO,CAACrB,gBAAgB,CAAC,CAClDsB,MAAM,CAAC,CAAC,CAACX,GAAG,CAAC,KAAKA,GAAG,CAACY,UAAU,CAAC,GAAGT,IAAI,CAACF,OAAO,GAAG,CAAC,CAAC,CAAC;IAAA,CACtDY,OAAO,CAAC,CAAC,CAACb,GAAG,EAAEvB,IAAI,CAAC,KAAKA,IAAI,CAAC,CAAC,CAAC;;IAEnC,IAAIqC,iBAAiB,GAAGV,iBAAiB;IACzC,IAAIW,eAAe,GAAGT,eAAe;;IAErC;IACA,KAAK,MAAMd,GAAG,IAAIgB,YAAY,EAAE;MAC9B,IAAIM,iBAAiB,IAAI,CAAC,IAAIC,eAAe,IAAI,CAAC,EAAE,MAAM,CAAC;;MAE3D;MACA,IAAIX,iBAAiB,GAAG,CAAC,IAAIZ,GAAG,CAACa,QAAQ,GAAG,CAAC,EAAE;QAC7C,MAAMW,kBAAkB,GAAGC,IAAI,CAACC,GAAG,CAACJ,iBAAiB,EAAEtB,GAAG,CAACa,QAAQ,CAAC;QACpEb,GAAG,CAACa,QAAQ,IAAIW,kBAAkB;QAClCF,iBAAiB,IAAIE,kBAAkB;MACzC;;MAEA;MACA,IAAIV,eAAe,GAAG,CAAC,IAAId,GAAG,CAACe,MAAM,GAAG,CAAC,EAAE;QACzC,MAAMY,gBAAgB,GAAGF,IAAI,CAACC,GAAG,CAACH,eAAe,EAAEvB,GAAG,CAACe,MAAM,CAAC;QAC9Df,GAAG,CAACe,MAAM,IAAIY,gBAAgB;QAC9BJ,eAAe,IAAII,gBAAgB;MACrC;IACF;EACF;;EAEA;EACA;;EAEA,OAAOvC,WAAW,CAAC,CAAC;AACtB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}